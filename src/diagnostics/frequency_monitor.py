"""
Ï£ºÌååÏàò Ìé∏Ï∞® Î™®ÎãàÌÑ∞ÎßÅ Î∞è ÏïåÎûå
AI Î™©Ìëú vs VFD Ïã§Ï†ú Ï£ºÌååÏàò ÎπÑÍµê
"""
from dataclasses import dataclass
from typing import List, Optional, Dict
from datetime import datetime
from enum import Enum


class DeviationCause(Enum):
    """Ìé∏Ï∞® ÏõêÏù∏"""
    COMMUNICATION_DELAY = "communication_delay"  # VFD ÌÜµÏã† ÏßÄÏó∞
    CONTROL_RESPONSE = "control_response"  # VFD Ï†úÏñ¥ ÏùëÎãµ Î¨∏Ï†ú
    MECHANICAL_OVERLOAD = "mechanical_overload"  # Í∏∞Í≥ÑÏ†Å Î∂ÄÌïò Í≥ºÎã§
    SENSOR_ERROR = "sensor_error"  # ÏÑºÏÑú Ïò§Î•ò Í∞ÄÎä•ÏÑ±
    UNKNOWN = "unknown"  # ÏõêÏù∏ Î∂àÎ™Ö


@dataclass
class FrequencyDeviation:
    """Ï£ºÌååÏàò Ìé∏Ï∞® Í∏∞Î°ù"""
    timestamp: datetime
    vfd_id: str
    target_frequency_hz: float  # AI Î™©Ìëú Ï£ºÌååÏàò
    actual_frequency_hz: float  # VFD Ïã§Ï†ú Ï£ºÌååÏàò
    deviation_hz: float  # Ìé∏Ï∞®
    deviation_percent: float  # Ìé∏Ï∞®Ïú® (%)
    cause: DeviationCause  # ÏõêÏù∏
    recommendation: str  # ÎåÄÏùë Î∞©Ïïà


@dataclass
class FrequencyAlarm:
    """Ï£ºÌååÏàò ÏïåÎûå"""
    alarm_id: str
    timestamp: datetime
    vfd_id: str
    severity: str  # "minor", "major", "critical"
    deviation: FrequencyDeviation
    acknowledged: bool
    acknowledged_by: Optional[str]
    acknowledged_at: Optional[datetime]


class FrequencyMonitor:
    """
    Ï£ºÌååÏàò Ìé∏Ï∞® Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú

    - AI Î™©Ìëú Ï£ºÌååÏàò vs VFD Ïã§Ï†ú Ï£ºÌååÏàò ÎπÑÍµê
    - Ìé∏Ï∞® 0.5Hz Ï¥àÍ≥ºÏãú ÏïåÎûå
    - ÏõêÏù∏ ÏûêÎèô Î∂ÑÏÑù
    """

    def __init__(self, deviation_threshold_hz: float = 0.5):
        """
        Args:
            deviation_threshold_hz: Ìé∏Ï∞® ÏûÑÍ≥ÑÍ∞í (Hz)
        """
        self.deviation_threshold = deviation_threshold_hz

        # Ìé∏Ï∞® ÌûàÏä§ÌÜ†Î¶¨
        self.deviation_history: Dict[str, List[FrequencyDeviation]] = {}

        # ÏïåÎûå Î¶¨Ïä§Ìä∏
        self.active_alarms: List[FrequencyAlarm] = []
        self.alarm_history: List[FrequencyAlarm] = []
        self.alarm_counter = 0

        # ÌÜµÍ≥Ñ
        self.total_checks = 0
        self.total_deviations = 0

    def check_frequency_deviation(
        self,
        vfd_id: str,
        target_freq: float,
        actual_freq: float,
        vfd_current_a: Optional[float] = None,
        vfd_torque_percent: Optional[float] = None,
        communication_delay_ms: Optional[float] = None
    ) -> Optional[FrequencyDeviation]:
        """
        Ï£ºÌååÏàò Ìé∏Ï∞® Ï≤¥ÌÅ¨

        Args:
            vfd_id: VFD ID
            target_freq: AI Î™©Ìëú Ï£ºÌååÏàò
            actual_freq: VFD Ïã§Ï†ú Ï£ºÌååÏàò
            vfd_current_a: VFD Ï†ÑÎ•ò (ÏòµÏÖò)
            vfd_torque_percent: VFD ÌÜ†ÌÅ¨ (ÏòµÏÖò)
            communication_delay_ms: ÌÜµÏã† ÏßÄÏó∞ (ÏòµÏÖò)

        Returns:
            FrequencyDeviation (Ìé∏Ï∞® ÏûàÎäî Í≤ΩÏö∞)
        """
        self.total_checks += 1

        # Ìé∏Ï∞® Í≥ÑÏÇ∞
        deviation_hz = abs(actual_freq - target_freq)
        deviation_percent = (deviation_hz / target_freq) * 100.0 if target_freq > 0 else 0.0

        # ÏûÑÍ≥ÑÍ∞í Ï≤¥ÌÅ¨
        if deviation_hz <= self.deviation_threshold:
            return None  # Ï†ïÏÉÅ

        self.total_deviations += 1

        # ÏõêÏù∏ Î∂ÑÏÑù
        cause = self._analyze_deviation_cause(
            vfd_id, deviation_hz, vfd_current_a, vfd_torque_percent, communication_delay_ms
        )

        # ÎåÄÏùë Î∞©Ïïà
        recommendation = self._generate_recommendation(cause, deviation_hz)

        deviation = FrequencyDeviation(
            timestamp=datetime.now(),
            vfd_id=vfd_id,
            target_frequency_hz=target_freq,
            actual_frequency_hz=actual_freq,
            deviation_hz=deviation_hz,
            deviation_percent=deviation_percent,
            cause=cause,
            recommendation=recommendation
        )

        # ÌûàÏä§ÌÜ†Î¶¨ Ï†ÄÏû•
        if vfd_id not in self.deviation_history:
            self.deviation_history[vfd_id] = []

        self.deviation_history[vfd_id].append(deviation)

        # ÌûàÏä§ÌÜ†Î¶¨ ÌÅ¨Í∏∞ Ï†úÌïú (ÏµúÍ∑º 500Í∞ú)
        if len(self.deviation_history[vfd_id]) > 500:
            self.deviation_history[vfd_id] = self.deviation_history[vfd_id][-500:]

        # ÏïåÎûå ÏÉùÏÑ± (Ìé∏Ï∞®Í∞Ä ÌÅ∞ Í≤ΩÏö∞)
        if deviation_hz > self.deviation_threshold * 2:  # 1.0Hz Ïù¥ÏÉÅ
            self._create_alarm(deviation)

        return deviation

    def _analyze_deviation_cause(
        self,
        vfd_id: str,
        deviation_hz: float,
        vfd_current: Optional[float],
        vfd_torque: Optional[float],
        comm_delay: Optional[float]
    ) -> DeviationCause:
        """Ìé∏Ï∞® ÏõêÏù∏ Î∂ÑÏÑù"""
        # 1. ÌÜµÏã† ÏßÄÏó∞ Ï≤¥ÌÅ¨
        if comm_delay is not None and comm_delay > 500:  # 500ms Ïù¥ÏÉÅ
            return DeviationCause.COMMUNICATION_DELAY

        # 2. Í∏∞Í≥ÑÏ†Å Î∂ÄÌïò Í≥ºÎã§
        if vfd_torque is not None and vfd_torque > 110:  # 110% Ïù¥ÏÉÅ
            return DeviationCause.MECHANICAL_OVERLOAD

        if vfd_current is not None:
            # Ï†ïÍ≤© Ï†ÑÎ•ò ÎåÄÎπÑ Í≥ºÏ†ÑÎ•ò (Í∞ÑÎã®Ìïú Ï∂îÏ†ï)
            if vfd_current > 200:  # Í∞ÄÏ†ï: Ï†ïÍ≤© 200A
                return DeviationCause.MECHANICAL_OVERLOAD

        # 3. Ï†úÏñ¥ ÏùëÎãµ Î¨∏Ï†ú (ÌûàÏä§ÌÜ†Î¶¨ Í∏∞Î∞ò)
        if vfd_id in self.deviation_history:
            recent = self.deviation_history[vfd_id][-10:]
            if len(recent) >= 5:
                # ÏµúÍ∑º 10Í∞ú Ï§ë 5Í∞ú Ïù¥ÏÉÅ Ìé∏Ï∞® = Ï†úÏñ¥ ÏùëÎãµ Î¨∏Ï†ú
                return DeviationCause.CONTROL_RESPONSE

        # 4. Ìé∏Ï∞®Í∞Ä Îß§Ïö∞ ÌÅ∞ Í≤ΩÏö∞ - ÏÑºÏÑú Ïò§Î•ò ÏùòÏã¨
        if deviation_hz > 5.0:
            return DeviationCause.SENSOR_ERROR

        return DeviationCause.UNKNOWN

    def _generate_recommendation(
        self,
        cause: DeviationCause,
        deviation_hz: float
    ) -> str:
        """ÎåÄÏùë Î∞©Ïïà ÏÉùÏÑ±"""
        recommendations = {
            DeviationCause.COMMUNICATION_DELAY: (
                "Modbus ÌÜµÏã† ÏÉÅÌÉú Ï†êÍ≤Ä ÌïÑÏöî. "
                "ÎÑ§Ìä∏ÏõåÌÅ¨ ÏºÄÏù¥Î∏î Î∞è ÌÜµÏã† ÌååÎùºÎØ∏ÌÑ∞ ÌôïÏù∏"
            ),
            DeviationCause.CONTROL_RESPONSE: (
                "VFD Ï†úÏñ¥ ÌååÎùºÎØ∏ÌÑ∞ Ïû¨ÏÑ§Ï†ï Í∂åÏû•. "
                "Í∞ÄÏÜç/Í∞êÏÜç ÏãúÍ∞Ñ Ï°∞Ï†ï ÌïÑÏöî"
            ),
            DeviationCause.MECHANICAL_OVERLOAD: (
                "Í∏∞Í≥Ñ Î∂ÄÌïò Ï†êÍ≤Ä ÌïÑÏöî. "
                "ÌéåÌîÑ/Ìå¨ Î≤†Ïñ¥ÎßÅ, ÏûÑÌé†Îü¨ ÏÉÅÌÉú ÌôïÏù∏"
            ),
            DeviationCause.SENSOR_ERROR: (
                "ÏÜçÎèÑ ÌîºÎìúÎ∞± ÏÑºÏÑú Ï†êÍ≤Ä ÌïÑÏöî. "
                "ÏóîÏΩîÎçî ÎòêÎäî ÌôÄÏÑºÏÑú ÌôïÏù∏"
            ),
            DeviationCause.UNKNOWN: (
                "Ìé∏Ï∞® ÏõêÏù∏ Î™®ÎãàÌÑ∞ÎßÅ Ï§ë. "
                "ÏßÄÏÜçÏãú Ï†ÑÎ¨∏Í∞Ä Ï†êÍ≤Ä Í∂åÏû•"
            )
        }

        base_rec = recommendations.get(cause, "ÏõêÏù∏ Î∂ÑÏÑù ÌïÑÏöî")

        # Ìé∏Ï∞® ÌÅ¨Í∏∞Ïóê Îî∞Î•∏ Ï∂îÍ∞Ä Í∂åÍ≥†
        if deviation_hz > 2.0:
            base_rec += " | ‚ö†Ô∏è Ï¶âÏãú Ï°∞Ïπò ÌïÑÏöî"
        elif deviation_hz > 1.0:
            base_rec += " | Ï°∞Í∏∞ Ï†êÍ≤Ä Í∂åÏû•"

        return base_rec

    def _create_alarm(self, deviation: FrequencyDeviation):
        """ÏïåÎûå ÏÉùÏÑ±"""
        self.alarm_counter += 1
        alarm_id = f"FREQ_ALARM_{self.alarm_counter:06d}"

        # Ïã¨Í∞ÅÎèÑ ÌåêÏ†ï
        if deviation.deviation_hz > 3.0:
            severity = "critical"
        elif deviation.deviation_hz > 1.5:
            severity = "major"
        else:
            severity = "minor"

        alarm = FrequencyAlarm(
            alarm_id=alarm_id,
            timestamp=deviation.timestamp,
            vfd_id=deviation.vfd_id,
            severity=severity,
            deviation=deviation,
            acknowledged=False,
            acknowledged_by=None,
            acknowledged_at=None
        )

        self.active_alarms.append(alarm)
        self.alarm_history.append(alarm)

        print(f"\nüö® Ï£ºÌååÏàò Ìé∏Ï∞® ÏïåÎûå Î∞úÏÉù")
        print(f"   ÏïåÎûå ID: {alarm_id}")
        print(f"   VFD: {deviation.vfd_id}")
        print(f"   Ïã¨Í∞ÅÎèÑ: {severity}")
        print(f"   Ìé∏Ï∞®: {deviation.deviation_hz:.2f}Hz ({deviation.deviation_percent:.1f}%)")
        print(f"   ÏõêÏù∏: {deviation.cause.value}")
        print(f"   Í∂åÍ≥†: {deviation.recommendation}\n")

    def acknowledge_alarm(self, alarm_id: str, acknowledged_by: str):
        """ÏïåÎûå ÌôïÏù∏"""
        for alarm in self.active_alarms:
            if alarm.alarm_id == alarm_id:
                alarm.acknowledged = True
                alarm.acknowledged_by = acknowledged_by
                alarm.acknowledged_at = datetime.now()

                # ÌôúÏÑ± ÏïåÎûåÏóêÏÑú Ï†úÍ±∞
                self.active_alarms.remove(alarm)
                return True

        return False

    def get_active_alarms(self) -> List[FrequencyAlarm]:
        """ÌôúÏÑ± ÏïåÎûå Î™©Î°ù"""
        return self.active_alarms.copy()

    def get_deviation_statistics(self, vfd_id: Optional[str] = None) -> Dict:
        """Ìé∏Ï∞® ÌÜµÍ≥Ñ"""
        if vfd_id:
            # ÌäπÏ†ï VFD
            if vfd_id not in self.deviation_history:
                return {
                    'vfd_id': vfd_id,
                    'total_deviations': 0,
                    'avg_deviation_hz': 0.0,
                    'max_deviation_hz': 0.0
                }

            deviations = self.deviation_history[vfd_id]
            return {
                'vfd_id': vfd_id,
                'total_deviations': len(deviations),
                'avg_deviation_hz': sum(d.deviation_hz for d in deviations) / len(deviations),
                'max_deviation_hz': max(d.deviation_hz for d in deviations),
                'most_common_cause': self._get_most_common_cause(deviations)
            }
        else:
            # Ï†ÑÏ≤¥
            all_deviations = []
            for deviations in self.deviation_history.values():
                all_deviations.extend(deviations)

            if not all_deviations:
                return {
                    'total_checks': self.total_checks,
                    'total_deviations': 0,
                    'deviation_rate_percent': 0.0
                }

            return {
                'total_checks': self.total_checks,
                'total_deviations': self.total_deviations,
                'deviation_rate_percent': (self.total_deviations / self.total_checks) * 100.0,
                'avg_deviation_hz': sum(d.deviation_hz for d in all_deviations) / len(all_deviations),
                'max_deviation_hz': max(d.deviation_hz for d in all_deviations),
                'total_alarms': len(self.alarm_history),
                'active_alarms': len(self.active_alarms)
            }

    def _get_most_common_cause(self, deviations: List[FrequencyDeviation]) -> str:
        """Í∞ÄÏû• ÌùîÌïú ÏõêÏù∏"""
        if not deviations:
            return "N/A"

        causes = [d.cause for d in deviations]
        most_common = max(set(causes), key=causes.count)
        return most_common.value

    def get_deviation_trend(self, vfd_id: str, recent_count: int = 20) -> List[float]:
        """Ìé∏Ï∞® Ï∂îÏù¥ (ÏµúÍ∑º NÍ∞ú)"""
        if vfd_id not in self.deviation_history:
            return []

        recent = self.deviation_history[vfd_id][-recent_count:]
        return [d.deviation_hz for d in recent]
